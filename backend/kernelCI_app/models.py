"""Defines the models used in the main database.
All models should have explicit id column for the ingester to work properly."""

from django.db import models
from django.contrib.postgres.fields import ArrayField
from django.contrib.postgres.indexes import GinIndex
from django.db.models import F, Q
from django.db.models.functions import Concat, MD5
from django.db.models.expressions import RawSQL


class StatusChoices(models.TextChoices):
    PASS = "PASS"
    FAIL = "FAIL"
    SKIP = "SKIP"
    ERROR = "ERROR"
    MISS = "MISS"
    DONE = "DONE"


class SimplifiedStatusChoices(models.TextChoices):
    PASS = "P"
    FAIL = "F"
    INCONCLUSIVE = "I"


class Issues(models.Model):
    field_timestamp = models.DateTimeField(
        db_column="_timestamp", blank=True, null=True
    )
    id = models.TextField(primary_key=True)
    version = models.IntegerField()  # version is also part of the primary key in kcidb
    origin = models.TextField()
    report_url = models.TextField(blank=True, null=True)
    report_subject = models.TextField(blank=True, null=True)
    culprit_code = models.BooleanField(blank=True, null=True)
    culprit_tool = models.BooleanField(blank=True, null=True)
    culprit_harness = models.BooleanField(blank=True, null=True)
    comment = models.TextField(blank=True, null=True)
    misc = models.JSONField(blank=True, null=True)
    categories = ArrayField(models.TextField(), blank=True, null=True)

    class Meta:
        db_table = "issues"
        unique_together = (("id", "version"),)
        indexes = [
            models.Index(fields=["field_timestamp"], name="issues__timestamp"),
            GinIndex(fields=["categories"], name="issues_categories"),
            models.Index(fields=["culprit_code"], name="issues_culprit_code"),
            models.Index(fields=["culprit_harness"], name="issues_culprit_harness"),
            models.Index(fields=["culprit_tool"], name="issues_culprit_tool"),
            models.Index(fields=["origin"], name="issues_origin"),
        ]


class Checkouts(models.Model):
    field_timestamp = models.DateTimeField(
        db_column="_timestamp", blank=True, null=True
    )
    id = models.TextField(primary_key=True)
    origin = models.TextField()
    tree_name = models.TextField(blank=True, null=True)
    git_repository_url = models.TextField(blank=True, null=True)
    git_commit_hash = models.TextField(blank=True, null=True)
    git_commit_name = models.TextField(blank=True, null=True)
    git_repository_branch = models.TextField(blank=True, null=True)
    patchset_files = models.JSONField(blank=True, null=True)
    patchset_hash = models.TextField(blank=True, null=True)
    message_id = models.TextField(blank=True, null=True)
    comment = models.TextField(blank=True, null=True)
    start_time = models.DateTimeField(blank=True, null=True)
    log_url = models.TextField(blank=True, null=True)
    log_excerpt = models.CharField(max_length=16384, blank=True, null=True)
    valid = models.BooleanField(blank=True, null=True)
    misc = models.JSONField(blank=True, null=True)
    git_commit_message = models.TextField(blank=True, null=True)
    git_repository_branch_tip = models.BooleanField(blank=True, null=True)
    git_commit_tags = ArrayField(models.TextField(), blank=True, null=True)
    origin_builds_finish_time = models.DateTimeField(blank=True, null=True)
    origin_tests_finish_time = models.DateTimeField(blank=True, null=True)

    class Meta:
        db_table = "checkouts"
        indexes = [
            models.Index(fields=["field_timestamp"], name="checkouts__timestamp"),
            models.Index(fields=["git_commit_hash"], name="checkouts_commit_hash"),
            models.Index(fields=["git_commit_name"], name="checkouts_commit_name"),
            GinIndex(fields=["git_commit_tags"], name="checkouts_commit_tags"),
            models.Index(fields=["git_repository_branch"], name="checkouts_git_branch"),
            models.Index(fields=["git_repository_url"], name="checkouts_git_url"),
            models.Index(fields=["origin"], name="checkouts_origin"),
            models.Index(fields=["start_time"], name="checkouts_start_time"),
            models.Index(fields=["tree_name"], name="checkouts_tree_name"),
        ]


class Builds(models.Model):
    field_timestamp = models.DateTimeField(
        db_column="_timestamp", blank=True, null=True
    )
    checkout = models.ForeignKey(
        Checkouts, db_constraint=False, on_delete=models.DO_NOTHING
    )
    id = models.TextField(primary_key=True)
    origin = models.TextField()
    comment = models.TextField(blank=True, null=True)
    start_time = models.DateTimeField(blank=True, null=True)
    duration = models.FloatField(blank=True, null=True)
    architecture = models.TextField(blank=True, null=True)
    command = models.TextField(blank=True, null=True)
    compiler = models.TextField(blank=True, null=True)
    input_files = models.JSONField(blank=True, null=True)
    output_files = models.JSONField(blank=True, null=True)
    config_name = models.TextField(blank=True, null=True)
    config_url = models.TextField(blank=True, null=True)
    log_url = models.TextField(blank=True, null=True)
    log_excerpt = models.CharField(max_length=16384, blank=True, null=True)
    misc = models.JSONField(blank=True, null=True)
    status = models.CharField(
        max_length=10, choices=StatusChoices.choices, blank=True, null=True
    )
    series = models.GeneratedField(
        expression=MD5(
            Concat(
                F("config_name"),
                F("compiler"),
                F("architecture"),
            ),
        ),
        output_field=models.TextField(blank=True, null=True),
        db_persist=True,
    )

    class Meta:
        db_table = "builds"
        indexes = [
            models.Index(fields=["field_timestamp"], name="builds__timestamp"),
            models.Index(fields=["architecture"], name="builds_architecture"),
            models.Index(fields=["compiler"], name="builds_compiler"),
            models.Index(fields=["config_name"], name="builds_config_name"),
            models.Index(fields=["origin"], name="builds_origin"),
            models.Index(fields=["start_time"], name="builds_start_time"),
            models.Index(fields=["series"], name="builds_series_idx"),
            models.Index(fields=["status"], name="builds_status"),
        ]


class Tests(models.Model):
    # Disables automatic pytest test discovery for this class
    __test__ = False

    class UnitPrefix(models.TextChoices):
        METRIC = "metric"
        BINARY = "binary"

    field_timestamp = models.DateTimeField(
        db_column="_timestamp", blank=True, null=True
    )
    build = models.ForeignKey(Builds, db_constraint=False, on_delete=models.DO_NOTHING)
    id = models.TextField(primary_key=True)
    origin = models.TextField()
    environment_comment = models.TextField(blank=True, null=True)
    environment_misc = models.JSONField(blank=True, null=True)
    path = models.TextField(blank=True, null=True)
    comment = models.TextField(blank=True, null=True)
    log_url = models.TextField(blank=True, null=True)
    log_excerpt = models.CharField(max_length=16384, blank=True, null=True)
    status = models.CharField(
        max_length=10, choices=StatusChoices.choices, blank=True, null=True
    )
    start_time = models.DateTimeField(blank=True, null=True)
    duration = models.FloatField(blank=True, null=True)
    output_files = models.JSONField(blank=True, null=True)
    misc = models.JSONField(blank=True, null=True)
    number_value = models.FloatField(blank=True, null=True)
    environment_compatible = ArrayField(models.TextField(), blank=True, null=True)
    number_prefix = models.CharField(
        max_length=10, choices=UnitPrefix.choices, blank=True, null=True
    )
    number_unit = models.TextField(blank=True, null=True)
    input_files = models.JSONField(blank=True, null=True)

    class Meta:
        db_table = "tests"
        indexes = [
            models.Index(fields=["field_timestamp"], name="tests__timestamp"),
            GinIndex(
                fields=["environment_compatible"], name="tests_environment_compatible"
            ),
            models.Index(fields=["origin"], name="tests_origin"),
            models.Index(fields=["path"], name="tests_path"),
            models.Index(
                RawSQL("(environment_misc ->> 'platform')", []),
                name="tests_platform_idx",
            ),
            models.Index(fields=["start_time"], name="tests_start_time"),
            models.Index(fields=["status"], name="tests_status"),
            # IMPORTANT: the next index is defined with where `environment_misc -> 'platform' IS NOT NULL`
            # This is not the desired behavior, it should be where
            # `environment_misc ->> 'platform' IS NOT NULL`, attention to the `->>`.
            # However Django doesn't seem to allow this format in a `condition` (Q) parameter. And we
            # must use `condition` since we are using the `fields` param as well. See PostgreSQL note on:
            # https://docs.djangoproject.com/en/5.2/topics/db/queries/#module-django.db.models.fields.json
            #
            # The fix is that in the migration we create the right condition separately, using raw sql.
            # *Check the migration for when this was added*.
            models.Index(
                fields=["origin", "start_time"],
                condition=Q(environment_misc__platform__isnull=False),
                name="tests_origin_time_platform",
            ),
        ]


class Incidents(models.Model):
    field_timestamp = models.DateTimeField(
        db_column="_timestamp", blank=True, null=True
    )
    id = models.TextField(primary_key=True)
    origin = models.TextField()
    issue = models.ForeignKey(Issues, db_constraint=False, on_delete=models.DO_NOTHING)
    issue_version = models.IntegerField()
    build = models.ForeignKey(
        Builds, db_constraint=False, null=True, blank=True, on_delete=models.DO_NOTHING
    )
    test = models.ForeignKey(
        Tests, db_constraint=False, null=True, blank=True, on_delete=models.DO_NOTHING
    )
    present = models.BooleanField(blank=True, null=True)
    comment = models.TextField(blank=True, null=True)
    misc = models.JSONField(blank=True, null=True)

    class Meta:
        db_table = "incidents"
        indexes = [
            models.Index(fields=["field_timestamp"], name="incidents__timestamp"),
            # Since there is no such thing as a composite foreign key, there is no automatic index on
            # (issue_id, issue_version). But since the issue_id alone is defined as an FK, there is
            # an automatic index on it. So we just need to add an index on issue_version alone.
            models.Index(fields=["issue_version"], name="incidents_issue_version"),
            models.Index(fields=["origin"], name="incidents_origin"),
        ]


class HardwareStatus(models.Model):
    pk = models.CompositePrimaryKey(
        "test_origin",
        "platform",
        "checkout_id",
    )
    checkout_id = models.TextField()
    test_origin = models.CharField(max_length=100)
    platform = models.CharField(max_length=100)

    compatibles = ArrayField(models.TextField(), null=True)
    start_time = models.DateTimeField()

    # build status
    build_pass = models.IntegerField(default=0)
    build_failed = models.IntegerField(default=0)
    build_inc = models.IntegerField(default=0)

    # boot status
    boot_pass = models.IntegerField(default=0)
    boot_failed = models.IntegerField(default=0)
    boot_inc = models.IntegerField(default=0)

    # test status
    test_pass = models.IntegerField(default=0)
    test_failed = models.IntegerField(default=0)
    test_inc = models.IntegerField(default=0)

    class Meta:
        db_table = "hardware_status"
        indexes = [
            models.Index(
                fields=["test_origin", "start_time"], name="hw_status_origin_time"
            ),
            models.Index(fields=["checkout_id"], name="hw_status_checkout_id"),
        ]


class LatestCheckout(models.Model):
    id = models.AutoField(primary_key=True)
    checkout_id = models.TextField()
    start_time = models.DateTimeField()

    origin = models.CharField(max_length=100)
    tree_name = models.TextField(null=True, blank=True)
    git_repository_url = models.TextField(null=True, blank=True)
    git_repository_branch = models.TextField(null=True, blank=True)

    class Meta:
        db_table = "latest_checkout"
        constraints = [
            models.UniqueConstraint(
                fields=[
                    "origin",
                    "tree_name",
                    "git_repository_url",
                    "git_repository_branch",
                ],
                name="latest_checkout_unique",
                nulls_distinct=False,
            ),
        ]
        indexes = [
            models.Index(fields=["checkout_id"], name="latest_checkout_checkout_id"),
        ]


class PendingTest(models.Model):
    test_id = models.TextField(primary_key=True)
    origin = models.CharField(max_length=100)
    platform = models.CharField(max_length=100)
    compatible = ArrayField(models.TextField(), null=True)
    build_id = models.TextField()
    status = models.CharField(
        max_length=1, choices=SimplifiedStatusChoices.choices, null=True
    )
    is_boot = models.BooleanField()

    class Meta:
        db_table = "pending_test"


class ProcessedListingItems(models.Model):
    listing_item_key = models.BinaryField(
        max_length=32,
        primary_key=True,
    )  # this holds a sha256, thus digest_size = 32 bytes
    checkout_id = models.TextField()
    # If we already processed an item, but the previous status is null and the new one is not-null,
    # we need to process it again. That's why we store the status here.
    status = models.CharField(
        max_length=1, choices=SimplifiedStatusChoices.choices, null=True
    )

    class Meta:
        db_table = "processed_listing_items"
        indexes = [
            models.Index(fields=["checkout_id"], name="phs_checkout_id"),
        ]


class PendingBuilds(models.Model):
    build_id = models.TextField(primary_key=True)
    origin = models.CharField(max_length=100)
    checkout_id = models.TextField()
    status = models.CharField(
        max_length=1, choices=SimplifiedStatusChoices.choices, null=True
    )

    class Meta:
        db_table = "pending_builds"


class TreeListing(models.Model):
    # Not using composite primary key here because
    # the combination for a unique tree can have null values
    # (origin, tree_name, branch, url)
    id = models.AutoField(primary_key=True)
    checkout_id = models.TextField()
    origin = models.TextField()
    tree_name = models.TextField(blank=True, null=True)
    git_repository_url = models.TextField(blank=True, null=True)
    git_repository_branch = models.TextField(blank=True, null=True)
    git_commit_hash = models.TextField(blank=True, null=True)
    git_commit_name = models.TextField(blank=True, null=True)
    git_commit_tags = ArrayField(models.TextField(), blank=True, null=True)
    start_time = models.DateTimeField(blank=True, null=True)

    build_pass = models.IntegerField(default=0)
    build_failed = models.IntegerField(default=0)
    build_inc = models.IntegerField(default=0)

    boot_pass = models.IntegerField(default=0)
    boot_failed = models.IntegerField(default=0)
    boot_inc = models.IntegerField(default=0)

    test_pass = models.IntegerField(default=0)
    test_failed = models.IntegerField(default=0)
    test_inc = models.IntegerField(default=0)

    class Meta:
        db_table = "tree_listing"
        constraints = [
            models.UniqueConstraint(
                fields=[
                    "origin",
                    "tree_name",
                    "git_repository_url",
                    "git_repository_branch",
                ],
                name="tree_listing_tree_unique",
            ),
        ]
        indexes = [
            models.Index(fields=["start_time"], name="tree_listing_start_time"),
            models.Index(fields=["checkout_id"], name="tree_listing_checkout_id"),
        ]
